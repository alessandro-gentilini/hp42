# -*- Mode:Org; Coding:utf-8; fill-column:158 -*-
#+TITLE:       free42 Programming Tools
#+AUTHOR:      Mitch Richling
#+EMAIL:       http://www.mitchr.me/
#+DATE:        2021-03-19
#+DESCRIPTION: Random stuff to assist with free42/hp-42s/DM42 programing
#+LANGUAGE:    en
#+OPTIONS:     num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t skip:nil d:nil todo:t pri:nil H:5 p:t author:t html-scripts:nil
#+HTML_HEAD: <style>body { width: 95%; margin: 2% auto; font-size: 18px; line-height: 1.4em; font-family: Georgia, serif; color: black; background-color: white; }</style>
#+HTML_HEAD: <style>body { min-width: 500px; max-width: 1024px; }</style>
#+HTML_HEAD: <style>h1,h2,h3,h4,h5,h6 { color: #A5573E; line-height: 1em; font-family: Helvetica, sans-serif; }</style>
#+HTML_HEAD: <style>h1,h2,h3 { line-height: 1.4em; }</style>
#+HTML_HEAD: <style>h1.title { font-size: 3em; }</style>
#+HTML_HEAD: <style>h4,h5,h6 { font-size: 1em; }</style>
#+HTML_HEAD: <style>.org-src-container { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; font-family: Lucida Console, monospace; font-size: 80%; margin: 0px; padding: 0px 0px; position: relative; }</style>
#+HTML_HEAD: <style>.org-src-container>pre { line-height: 1.2em; padding-top: 1.5em; margin: 0.5em; background-color: #404040; color: white; overflow: auto; }</style>
#+HTML_HEAD: <style>.org-src-container>pre:before { display: block; position: absolute; background-color: #b3b3b3; top: 0; right: 0; padding: 0 0.2em 0 0.4em; border-bottom-left-radius: 8px; border: 0; color: white; font-size: 100%; font-family: Helvetica, sans-serif;}</style>
#+HTML_HEAD: <style>pre.example { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; font-family: Lucida Console, monospace; font-size: 80%; background: #404040; color: white; display: block; padding: 0em; border: 2px solid black; }</style>
#+HTML_LINK_HOME: https://www.mitchr.me/
#+HTML_LINK_UP: https://richmit.github.io/hp42/
#+EXPORT_FILE_NAME: ../docs/hp42s-meta

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|        <r> | <l>              |
|  *Author:* | /{{{author}}}/ |
| *Updated:* | /{{{time(%Y-%m-%d %H:%M:%S)}}}/ |
#+ATTR_HTML: :align center
Copyright {{{time(%Y)}}} Mitch Richling. All rights reserved.

#+TOC: headlines 5

#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#   00   #    10   #    20   #    30   #    40   #    50   #    60   #    70   #    80   #    90   #   100   #   110   #   120   #   130   #   140   #   150   #   160   #
# 234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #

* Metadata

This home for this HTML file is: https://richmit.github.io/hp42/hp42s-meta.html

Files related to this document may be found on github: https://github.com/richmit/hp42

   - =src= directory: Contains the org-mode file that generated this HTML document
   - =docs= directory: Contains this html document
   - =bin= directory: Contains raw program files

* Introduction

This org-mode document contains various tools (mostly for Emacs) that help me write programs for the 42s:

   - Elisp function to generate 42s menu programs
   - A tool to insert free42 utf-8 characters given a list of character numbers
   - Elisp function to generate custom menus (menus of built-in functions and global labels)
   - yasnippet templates to help type code
   - ElISP Code to translate my code listings into code for free42 & MD42
   - 42s notes
     - free42 utf-8 characters with character numbers

* Generateing 42s code

** Menus

*** Generic menu generator

This code will read an org-mode table describing a menu, and generate 42s code to implement the menu.  The menus may be of arbitrary depth and size; however,
two digit local labels are used in the generated code which limits sizes.

=MJR-generate-42-menu-code= arguments:
  - =top-lab=  The global label to use for the generated program
  - =tbl= The org-mode table with the menu description
  - =leaf-function= What do do when a /action/ menu is used (a leaf node in the menu).
    - ="stay"= Keep the menu active.
    - ="exit"= Exit the menu.
  - =exit-function= What to do when =[EXIT]= is pressed.
    - ="exit"= Exit the application.
    - ="up"= Go up to parent, or exit if we are in the top menu.
  - =gen-code= A function that generates the code for the /action/.  It gets a list that contains the table row for the menu item.

The first column of the table defines the menu key labels.  =foo:bar:foobar= defines a top level button named =foo= that leads to a menu containing another
menu named =bar= which contains an /action/ named =foobar=.  The rest of the columns are used by the =gen-code= function to write the code for each item.  A
blank entry in the first column leaves a blank menu button.  A more complete example:

| Menu           |
|----------------|
| foo:bar:foobar |
| foo:bill       |
| foo:ted        |
| snoopy         |

The top level menu will have "=foo=" & "=snoopy=".  "=snoopy=" is an /action/ button while "=foo=" brings up a menu containing "=bar=", "=bill=", & "=ted=".
The last two are /actions/ while the first is yet another menu containing "=foobar=".

#+BEGIN_SRC elisp :results output verbatum
(defun MJR-generate-42-menu-code (top-lab tbl leaf-function exit-function gen-code) ;; leaf-function "stay" or "exit", exit-function "exit" or "up"
  (let* ((min-free-lab  2)
         (m-code "")
         (x-code ""))
    (cl-labels ((add-m-code (a) (setq m-code (concat m-code a "\n")))
                (add-x-code (a) (setq x-code (concat x-code a "\n")))
                (prc-mnu (menu) (if (or (not (listp menu))
                                        (null (cdr menu)))
                                    menu
                                    (mapcar #'prc-mnu
                                            (append (list (car menu))
                                                    (reverse (cl-reduce (lambda (result cur-elt)
                                                                          (let ((last-elt (cl-first result)))
                                                                            (if (and (listp last-elt)
                                                                                     (cdr last-elt)
                                                                                     (cdr cur-elt)
                                                                                     (string-equal (cl-first last-elt) (cl-first cur-elt)))
                                                                                (progn (nconc (cl-first result) (list (cdr cur-elt)))
                                                                                       result)
                                                                                (if (cdr cur-elt)
                                                                                    (append (list (list (cl-first cur-elt) (cdr cur-elt))) result)
                                                                                    (append (list (cl-first cur-elt))  result)))))
                                                                        (cdr menu)
                                                                        :initial-value ()))))))
                (gen-mnu (plbl lbl menu) (let* ((num-menu-keys (1- (length menu)))
                                                (num-menu-page (ceiling (/ num-menu-keys 6.0)))
                                                (page-labs     (cl-loop repeat num-menu-page
                                                                        for i = lbl then min-free-lab
                                                                        collect i
                                                                        when (not (= i lbl))
                                                                        do (cl-incf min-free-lab)))
                                                (rec-key-labs     nil)
                                                (rec-pag-labs     nil))
                                           (if (zerop plbl)
                                               (add-m-code (message "LBL \"%s\"" (cl-first menu))))
                                           (cl-loop for mkey-elt in (cdr menu)
                                                    for mkey-num from 0
                                                    for page-num = (truncate (/ mkey-num 6))
                                                    for page-key = (mod mkey-num 6)
                                                    for mkey-str = (if (vectorp mkey-elt) (aref mkey-elt 0) (cl-first mkey-elt))
                                                    when (= page-key 0)
                                                    do (progn (add-m-code (message "LBL %02d            @@@@ Page %d of menu %s" (nth page-num page-labs) (1+ page-num) (cl-first menu)))
                                                              (add-m-code "CLMENU"))
                                                    when (not (string-equal mkey-str ""))
                                                    do (progn (add-m-code (message "\"%s\"" mkey-str))
                                                              (add-m-code (message "KEY %d %s %02d" (1+ page-key) (if (vectorp mkey-elt) "XEQ" "GTO") min-free-lab))
                                                              (if (vectorp mkey-elt)
                                                                  (progn (add-x-code (message "LBL %02d               @@@@ Action for menu key %s" min-free-lab mkey-str))
                                                                         (add-x-code (funcall gen-code (aref mkey-elt 1)))
                                                                         (add-x-code "RTN")))
                                                              (push min-free-lab rec-key-labs)
                                                              (cl-incf min-free-lab)
                                                              (push (nth page-num page-labs) rec-pag-labs))
                                                    when (or (= page-key 5) (= mkey-num (1- num-menu-keys)))
                                                    do (progn (if (< 1 num-menu-page)
                                                                  (progn (add-m-code (message "KEY 7 GTO %02d" (nth (mod (1- page-num) num-menu-page) page-labs)))
                                                                         (add-m-code (message "KEY 8 GTO %02d" (nth (mod (1+ page-num) num-menu-page) page-labs)))))
                                                              (if (string-equal exit-function "up")
                                                                  (add-m-code (message "KEY 9 GTO %02d" plbl))
                                                                  (add-m-code (message "KEY 9 GTO %02d" 0)))
                                                              (add-m-code "MENU")
                                                              (add-m-code "STOP")
                                                              (if (string-equal leaf-function "stay")
                                                                  (add-m-code (message "GTO %02d" (nth page-num page-labs)))
                                                                  (add-m-code (message "GTO %02d" 0)))))
                                           (cl-loop for mkey-elt in (cdr menu)
                                                    for m-lab in (reverse rec-key-labs)
                                                    for p-lab in (reverse rec-pag-labs)
                                                    when (listp mkey-elt)
                                                    do (gen-mnu p-lab m-lab mkey-elt)))))
      (gen-mnu 0 1 (prc-mnu (append (list top-lab) (cl-loop for row in tbl
                                                            for n from 0
                                                            for tmp = (split-string (message "%s" (cl-first row)) ":")
                                                            do (setf (car (last tmp)) (vector (car (last tmp)) row))
                                                            collect tmp))))
      (add-m-code "LBL 00")
      (add-m-code "EXITALL")
      (add-m-code "RTN")
      (if (< 100 min-free-lab)
          (error "ERROR: Too many local labels: %d" min-free-lab)))
    (princ m-code)
    (princ x-code)
    (princ (message "@@@@ Free labels start at: %d\n" min-free-lab))
    (princ "END")))
#+END_SRC

#+RESULTS:

*** For CUSTOM-type Menus

This is a function for use as as the =gen-code= argument to =MJR-generate-42-menu-code=.  It generates a menu program that calls other programs or built in
functions -- it is very useful for generating menus to be assigned to the CUSTOM menu.  The second column of the defining table is used to specify a function
or program to call.  When the second column entry is empty, the string used for the key name is used.  Example:

| Menu   | Prog |
|--------+------|
| LN     |      |
| log    | LOG  |
| MYPROG |      |

In the first line "=LN=" is the menu name and function called.  In the second line "=log=" is the menu name, and "=LOG=" is the function called.  In the third
line "=MYPROG=" is the name of a program -- the code below figures out if a thing is a built in function or a program and uses =XEQ= for programs.  Note that
I may have missed a built in function, so you may have to add one to the list. ;)

#+BEGIN_SRC elisp :colnames y :results output verbatum
(defun MJR-custom-x-gen (row) (let ((blt-in  '("%" "%CH" "+" "+/-" "-" "1/X" "10↑X" "ABS" "ACOS" "ACOSH" "ADV" "AGRAPH" "AIP" "ALENG" "ALL" "ALLΣ" "AND" "AOFF" "AON" "ARCL" "AROT" "ASHF" "ASIN" "ASINH" "ASSIGN" "ASTO" "ATAN" "ATANH" "ATOX" "AVIEW"
                                               "BASE+" "BASE+/-" "BASE-" "BASE×" "BASE÷" "BEEP" "BEST" "BINM" "BIT?"  "BIT?"  "CF" "CLA" "CLD" "CLKEYS" "CLLCD" "CLMENU" "CLP" "CLRG" "CLST" "CLV" "CLX" "CLΣ" "COMB" "COMPLEX" "CORR" "COS" "COSH"
                                               "CPX?"  "CPXRES" "CROSS" "CUSTOM" "DECM" "DEG" "DELAY" "DELR" "DET" "DIM" "DIM?"  "DOT" "DSE" "EDIT" "EDITN" "END" "ENG" "ENTER" "EXITALL" "EXPF" "E↑X" "E↑X-1" "FC?"  "FC?C" "FCSTX" "FCSTY" "FIX"
                                               "FNRM" "FP" "FS?"  "FS?C" "FUNC" "GAMMA" "GETKEY" "GETM" "GRAD" "GROW" "GTO" "HEXM" "HMS+" "HMS-" "I+" "I-" "INDEX" "INPUT" "INSR" "INTEG" "INVRT" "IP" "ISG" "J+" "J-" "KEY" "KEYASN" "L4STK" "LASTX"
                                               "LBL" "LCLBL" "LINF" "LINΣ" "LN" "LN1+X" "LOG" "LOGF" "LSTO" "MAN" "MAT?"  "MEAN" "MENU" "MOD" "MVAR" "N!"  "NEWMAT" "NOP" "NORM" "NOT" "OCTM" "OFF" "OLD" "ON" "OR" "PERM" "PGMINT" "PGMSLV" "PIXEL"
                                               "POLAR" "POSA" "PRA" "PRLCD" "PROFF" "PROMPT" "PRON" "PRSTK" "PRUSR" "PRV" "PRX" "PRΣ" "PSE" "PUTM" "PWRF" "R<>R" "RAD" "RAN" "RCL" "RCL+" "RCL-" "RCLEL" "RCLIJ" "RCL×" "RCL÷" "RDX," "RDX."  "REAL?"
                                               "REALRES" "RECT" "RND" "RNRM" "ROTXY" "RSUM" "RTN" "RTNERR" "RTNYES" "RTNNO" "R↑" "R↓" "SCI" "SDEV" "SEED" "SF" "SIGN" "SIN" "SINH" "SIZE" "SLOPE" "SOLVE" "SQRT" "STO" "STO+" "STO-" "STOEL" "STOIJ" "STOP" "STO×"
                                               "STO÷" "STR?"  "SUM" "TAN" "TANH" "TONE" "TRACE" "TRANS" "UVEC" "VARMENU" "VIEW" "WMEAN" "WRAP" "WSIZE?"  "X<0?"  "X<>" "X<>Y" "X<Y?"  "X=0?"  "X=Y?"  "X>0?"  "X>Y?"  "XEQ" "XTOA" "X↑2" "X≠0?"
                                               "X≠Y?"  "X≤0?"  "X≤Y?"  "X≥0?"  "X≥Y?"  "X≥Y?"  "YINT" "Y↑X" "[FIND]" "[MAX]" "[MIN]" "×" "÷" "Σ+" "Σ-" "ΣREG" "ΣREG?"  "←" "↑" "→" "→DEC" "→DEG" "→HMS" "→HR" "→OCT" "→POL" "→RAD" "→REC" "↓"
                                               "DDAYS" "DOW" "CLK12" "CLK24" "DMY" "MDY" "YMD" "DATE" "TIME" "DATE+" "PI"))
                                    (cm-lb (if (not (string-equal "" (cl-second row)))
                                               (cl-second row)
                                               (car (last (split-string (cl-first row) ":"))))))
                                (if (cl-position cm-lb blt-in :test #'string-equal)
                                    (message "%s" cm-lb)
                                    (message "XEQ \"%s\"" cm-lb))))
#+END_SRC

#+RESULTS:

*** Template for empty menu code

#+NAME: menu
| Menu |
|------|
| a    |
| b    |
| c    |

#+BEGIN_SRC elisp :var tbl=menu :colnames y :results output verbatum :wrap "src hp42s :tangle yes"
(MJR-generate-42-menu-code "PROG_NAME" tbl "stay" "up" (lambda (x) ""))
#+END_SRC

#+RESULTS:
#+begin_src hp42s :tangle yes
LBL "PROG_NAME"
LBL 01            @@@@ Page 1 of menu PROG_NAME
CLMENU
"a"
KEY 1 XEQ 02
"b"
KEY 2 XEQ 03
"c"
KEY 3 XEQ 04
KEY 9 GTO 00
MENU
STOP
GTO 01
LBL 00
EXITALL
RTN
LBL 02               @@@@ Action for menu key a

RTN
LBL 03               @@@@ Action for menu key b

RTN
LBL 04               @@@@ Action for menu key c

RTN
@@@@ Free labels start at: 5
#+end_src

* Emacs Helper Stuff

** Emacs function to insert charcters given a list of character codes

#+BEGIN_SRC elisp :results output verbatum
(defun MJR-ins42char (charn)
  "Insert free42 character at point."
  (interactive "sCharacter Number(s): ")
  (if charn
      (cl-loop for c in (split-string charn)
               do (insert (nth (eval (car (read-from-string c))) '("÷" "×" "√"  "∫" "▒" "Σ" "▸" "π" "¿" "≤"     "[LF]" "≥"     "≠"  "↵" "↓" "→"
                                                                   "←" "μ" "£"  "°" "Å" "Ñ" "Ä" "∡" "ᴇ" "Æ"     "…"    "[ESC]" "Ö"  "Ü" "▒" "•"  ;; CHAR 30 & CHAR 4 are the same unicode.  Not sure how to type a char 30 into a string...
                                                                   " " "!" "\"" "#" "$" "%" "&" "'" "(" ")"     "*"    "+"     ","  "-" "." "/"
                                                                   "0" "1" "2"  "3" "4" "5" "6" "7" "8" "9"     ":"    ";"     "<"  "=" ">" "?"
                                                                   "@" "A" "B"  "C" "D" "E" "F" "G" "H" "I"     "J"    "K"     "L"  "M" "N" "O"
                                                                   "P" "Q" "R"  "S" "T" "U" "V" "W" "X" "Y"     "Z"    "["     "\\" "]" "↑" "_"
                                                                   "`" "a" "b"  "c" "d" "e" "f" "g" "h" "i"     "j"    "k"     "l"  "m" "n" "o"
                                                                   "p" "q" "r"  "s" "t" "u" "v" "w" "x" "y"     "z"    "{"     "|"  "}" "~" "├"
                                                                   ":" "ʏ"))))))
#+END_SRC

#+RESULTS:


** Emacs Mode for 42s Code

This isn't really a proper mode for 42s code.  Just a quick hack with =define-generic-mode= to get some syntax highlighting -- which doesn't fully work as
some of the characters in keywords are recognized as punctuation.  Still it makes listings a little better.  Someday I may take the time to write a real mode,
but this works for now.

#+BEGIN_SRC elisp
(define-generic-mode 'hp42s-mode
                     '("@@@@" "@@")
                     '("%" "%CH" "+" "+/-" "-" "1/X" "10↑X" "ABS" "ACOS" "ACOSH" "ADV" "AGRAPH" "AIP" "ALENG" "ALL" "ALLΣ" "AND" "AOFF" "AON" "ARCL" "AROT" "ASHF" "ASIN" "ASINH" "ASSIGN" "ASTO" "ATAN" "ATANH" "ATOX" "AVIEW"
                       "BASE+" "BASE+/-" "BASE-" "BASE×" "BASE÷" "BEEP" "BEST" "BINM" "BIT"  "BIT"  "CF" "CLA" "CLD" "CLKEYS" "CLLCD" "CLMENU" "CLP" "CLRG" "CLST" "CLV" "CLX" "CLΣ" "COMB" "COMPLEX" "CORR" "COS" "COSH"
                       "CPX"  "CPXRES" "CROSS" "CUSTOM" "DECM" "DEG" "DELAY" "DELR" "DET" "DIM" "DIM"  "DOT" "DSE" "EDIT" "EDITN" "END" "ENG" "ENTER" "EXITALL" "EXPF" "E↑X" "E↑X-1" "FC"  "FC?C" "FCSTX" "FCSTY" "FIX"
                       "FNRM" "FP" "FS"  "FS?C" "FUNC" "GAMMA" "GETKEY" "GETM" "GRAD" "GROW" "GTO" "HEXM" "HMS+" "HMS-" "I+" "I-" "INDEX" "INPUT" "INSR" "INTEG" "INVRT" "IP" "ISG" "J+" "J-" "KEY" "KEYASN" "L4STK" "LASTX"
                       "LBL" "LCLBL" "LINF" "LINΣ" "LN" "LN1+X" "LOG" "LOGF" "LSTO" "MAN" "MAT"  "MEAN" "MENU" "MOD" "MVAR" "N!"  "NEWMAT" "NOP" "NORM" "NOT" "OCTM" "OFF" "OLD" "ON" "OR" "PERM" "PGMINT" "PGMSLV" "PIXEL"
                       "POLAR" "POSA" "PRA" "PRLCD" "PROFF" "PROMPT" "PRON" "PRSTK" "PRUSR" "PRV" "PRX" "PRΣ" "PSE" "PUTM" "PWRF" "R<>R" "RAD" "RAN" "RCL" "RCL+" "RCL-" "RCLEL" "RCLIJ" "RCL×" "RCL÷" "RDX," "RDX."  "REAL"
                       "REALRES" "RECT" "RND" "RNRM" "ROTXY" "RSUM" "RTN" "RTNERR" "R↑" "R↓" "SCI" "SDEV" "SEED" "SF" "SIGN" "SIN" "SINH" "SIZE" "SLOPE" "SOLVE" "SQRT" "STO" "STO+" "STO-" "STOEL" "STOIJ" "STOP" "STO×"
                       "STO÷" "STR"  "SUM" "TAN" "TANH" "TONE" "TRACE" "TRANS" "UVEC" "VARMENU" "VIEW" "WMEAN" "WRAP" "WSIZE"  "X<0"  "X<>" "X<>Y" "X<Y"  "X=0"  "X=0" "X=Y"  "X>0"  "X>Y"  "XEQ" "XTOA" "X↑2" "X≠0"
                       "X≠Y"  "X≤0"  "X≤Y"  "X≥0"  "X≥Y"  "X≥Y"  "YINT" "Y↑X" "[FIND]" "[MAX]" "[MIN]" "×" "÷" "Σ+" "Σ-" "ΣREG" "ΣREG"  "←" "↑" "→" "→DEC" "→DEG" "→HMS" "→HR" "→OCT" "→POL" "→RAD" "→REC" "↓"
                       "DDAYS" "DOW" "CLK12" "CLK24" "DMY" "MDY" "YMD" "DATE" "TIME" "ADATE" "ATIME" "DATE+" "XEQ IND ST" "XEQ IND" "GTO IND" "GTO IND ST" "STO IND ST" "STO+ IND ST" "STO- IND ST" "STOEL IND ST"
                       "STOIJ IND ST" "STOP IND ST" "STO× IND ST" "STO÷ IND ST" "STO ST" "STO+ ST" "STO- ST" "STOEL ST" "STOIJ ST" "STOP ST" "STO× ST" "STO÷ ST" "RCL IND ST" "RCL+ IND ST" "RCL- IND ST" "RCLEL IND ST"
                       "RCLIJ IND ST" "RCL× IND ST" "RCL÷ IND ST" "RCL ST" "RCL+ ST" "RCL- ST" "RCLEL ST"
                       "RCLIJ ST" "RCL× ST" "RCL÷ ST"
                       "RTNNO" "RTNYES" "PI"
                       )
                     '(("@@## REQ:.*" . font-lock-preprocessor-face)) ;; Not sure why this is broken.
                     '(".42s\\'")
                     nil
                     "Major mode for editing HP-42s programs")
#+END_SRC

#+RESULTS:
#+begin_example
hp42s-mode
#+end_example

** yas templates

#+BEGIN_SRC sh :results output verbatum :wrap src snippet
echo ''
for f in ~/core/yasnippet/hp42s-mode/*; do cat $f; echo ''; done
#+END_SRC

#+RESULTS:
#+begin_src snippet

# -*- mode: snippet -*-
# name: if-then-end
# key: if
# --
...?   @@@@ IF-BEGIN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})
GTO ${1:1$(format "%02d" (string-to-number yas-text))}
GTO ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}
LBL $1 @@@@ IF-THEN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})
@@@@ True Code ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})
LBL ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))} @@@@ IF-END ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))})

# -*- mode: snippet -*-
# name: if-then-else-end
# key: ife
# --
...?   @@@@ IF-BEGIN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
GTO ${1:1$(format "%02d" (string-to-number yas-text))}
GTO ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}
LBL $1 @@@@ IF-THEN ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
@@@@ True Code ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
GTO ${1:$(format "%02d" (+ 2 (string-to-number yas-text)))}
LBL ${1:$(format "%02d" (+ 1 (string-to-number yas-text)))} @@@@ IF-ELSE ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
@@@@ False Code ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})
LBL ${1:$(format "%02d" (+ 2 (string-to-number yas-text)))} @@@@ IF-END ($1/${1:$(format "%02d" (+ 1 (string-to-number yas-text)))}/${1:$(format "%02d" (+ 2 (string-to-number yas-text)))})

# -*- mode: snippet -*-
# name: if-not-then-end
# key: ifn
# --
...?   @@@@ IF-NOT-BEGIN ($1)
GTO ${1:1$(format "%02d" (string-to-number yas-text))}
@@@@ False Code ($1)
LBL $1 @@@@ IF-NOT-END ($1)

# -*- mode: snippet -*-
# name: if-then-end-return
# key: ifr
# --
...?      @@@@ IF-BEGIN ($1)
GTO ${1:1$(format "%02d" (string-to-number yas-text))}    @@@@ IF-FALSE-BEGIN ($1)
@@@@ False Code ($1)
RTN       @@@@ IF-FALSE-END ($1)
LBL $1    @@@@ IF-TRUE-BEGIN ($1)
@@@@ True Code ($1)
RTN       @@@@ IF-TRUE-END ($1)

#+end_src

* Prepare Code For Conversion

I include comments like =@@##= that I use like compiler directives in C.  They provide a way to remove lines of code that are incompatible or unnecessary for
the target version of free42.  It's a bit of a hack, but it lets me maintain one program for diff-rent versions of free42.

** DM42 DMCP-3.20 / DM42-3.17

#+BEGIN_SRC elisp
(progn
  ;; Zap lines requireing a newer free24
  (query-replace-regexp "^.*@@## REQ:free42>=\\([0-9.]+\\)$" '(replace-eval-replacement replace-quote (if (version< "2.5.20" (match-string 1)) "" (match-string 0))) nil nil nil nil nil)
  (query-replace-regexp "^.*@@## USE:free42>=\\([0-9.]+\\)$" '(replace-eval-replacement replace-quote (if (version< "2.5.20" (match-string 1)) "" (match-string 0))) nil nil nil nil nil)
  ;; Zap comment lines
  (delete-matching-lines "^ *@@@@.*$" nil nil t)
  ;; Zap directive comments
  (query-replace-regexp " +@@## ...:.*$" "" nil nil nil nil nil)
  ;; Zap comments
  (query-replace-regexp " +@@@@.*$" "" nil nil nil nil nil)
  ;; Zap leading whitespace
  (query-replace-regexp "^ +" "" nil nil nil nil nil)
  ;; Zap empty lines
  (delete-matching-lines "^ *$" nil nil t))
#+END_SRC

** free42 3.0.1 or newer

#+BEGIN_SRC elisp
(progn
  ;; Zap comment lines
  (beginning-of-buffer)
  (delete-matching-lines "^ *@@@@.*$" nil nil t)
  ;; Zap directive comments
  (beginning-of-buffer)
  (query-replace-regexp " +@@## ...:.*$" "" nil nil nil nil nil)
  ;; Zap comments
  (beginning-of-buffer)
  (query-replace-regexp " +@@@@.*$" "" nil nil nil nil nil)
  ;; Zap leading whitespace
  (beginning-of-buffer)
  (query-replace-regexp "^ +" "" nil nil nil nil nil)
  ;; Zap empty lines
  (beginning-of-buffer)
  (delete-matching-lines "^ *$" nil nil t))
#+END_SRC


** Clean Tangled Code

This function cleans up tangled (C-c C-v t) code so that it can be cleanly pasted into free42.

#+BEGIN_SRC elisp
(defun MJR-process-tangled-42s-code ()
  "Prepare tangled hp42s code for upload"
  (interactive)
  ;; Zap comments
  (goto-char (point-min))
  (while (re-search-forward "\\(@@@@\\|@@##\\).*$" nil t)
    (replace-match ""))
  ;; Zap trailing whitespace
  (goto-char (point-min))
  (while (re-search-forward "  *$" nil t)
    (replace-match ""))
  ;; Zap blank lines
  (goto-char (point-min))  
  (flush-lines "^[[:space:]]*$")
  ;; Add lines after END commands
  (goto-char (point-min))
  (while (re-search-forward "^END$" nil t)
    (replace-match "END\n"))
  ;; Save the buffer
  (save-buffer)
  )
#+END_SRC

#+RESULTS:
#+begin_example
MJR-process-tangled-42s-code
#+end_example

#+BEGIN_SRC elisp
(add-hook 'org-babel-post-tangle-hook 'MJR-process-tangled-42s-code)
#+END_SRC

#+RESULTS:
| MJR-process-tangled-42s-code |

* 42s Notes

** Character Set

#+BEGIN_SRC text
   0 ÷
   1 ×
   2 √
   3 ∫
   4 ▒
   5 Σ
   6 ▸
   7 π
   8 ¿
   9 ≤
  10 [LF]
  11 ≥
  12 ≠
  13 ↵
  14 ↓
  15 →
  16 ←
  17 μ
  18 £
  19 °
  20 Å
  21 Ñ
  22 Ä
  23 ∡
  24 ᴇ
  25 Æ
  26 …
  27 [ESC]
  28 Ö
  29 Ü
  30 ▒
  31 •
  32 [SPACE]
  33 !
  34 "
  35 #
  36 $
  37 %
  38 &
  39 '
  40 (
  41 )
  42 *
  43 +
  44 ,
  45 -
  46 .
  47 /
  48 0
  49 1
  50 2
  51 3
  52 4
  53 5
  54 6
  55 7
  56 8
  57 9
  58 :
  59 ;
  60 <
  61 =
  62 >
  63 ?
  64 @
  65 A
  66 B
  67 C
  68 D
  69 E
  70 F
  71 G
  72 H
  73 I
  74 J
  75 K
  76 L
  77 M
  78 N
  79 O
  80 P
  81 Q
  82 R
  83 S
  84 T
  85 U
  86 V
  87 W
  88 X
  89 Y
  90 Z
  91 [
  92 \
  93 ]
  94 ↑
  95 _
  96 `
  97 a
  98 b
  99 c
 100 d
 101 e
 102 f
 103 g
 104 h
 105 i
 106 j
 107 k
 108 l
 109 m
 110 n
 111 o
 112 p
 113 q
 114 r
 115 s
 116 t
 117 u
 118 v
 119 w
 120 x
 121 y
 122 z
 123 {
 124 |
 125 }
 126 ~
 127 ├
 128 :
 129 ʏ
#+END_SRC

** Date format

| Flag 67 | Flag 31 | Mode |
|---------+---------+------|
| Set     | N/A     | Y.MD |
| Clear   | Clear   | M.DY |
| Clear   | Set     | D.MY |

* DM 42 Notes

** Display

GrMod is a read write variable.
   - 0 = standard HP-42S resolution 131x16
   - 2 = DM42 full resolution 200x120
   - 3 = DM42 full resolution 400x240

ResX & ResY are read only variables that have the display resolution

* EOF

# End of document.

# The following adds some space at the bottom of exported HTML
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
#+HTML: <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />
